[{"title":"51单片机按钮短长按和双击程序","date":"2020-05-04T14:17:58.000Z","path":"2020/05/04/button-exti/","raw":"---\ntitle: 51单片机按钮短长按和双击程序\ndate: 2020-05-04 22:17:58\ntags:\n---\n\n> 单片机型号：STC89C5xRC\n\n#### 引脚和变量定义\n``` C\n#define INT0_GPIO P32\t//中断IO引脚\nu8 key_flag = 0;\t\t//按键按下标志\n```\n\n#### 外部中断0初始化\n``` C\n\tIT0 = 1; //外部中断触发方式(1:下降沿，0：下降沿+上升沿)\n\tEX0 = 1; //打开外部中断\n\tEA = 1;\n```\n\n#### 中断函数\n``` C\nvoid int0_fun() interrupt 0\n{\n\tbit double_flag = 0;\n\tdelay(50);//延时消抖\n\tif(!INT0_GPIO){//被按下\n\t\tif(button_delay(500)){//长按500ms以上\n\t\t\tkey_flag = 2;\n\t\t}else if(button_delay(50)){//双击，第二次按100ms以上\n\t\t\tdouble_flag = 1;\t\t//1避开长按，使长按途中有空闲时间执行其他任务，2防止双击松开是抖动产生的二次双击\n\t\t\tkey_flag = 3;\n\t\t}else {//按键单击\n\t\t\tkey_flag = 1;\n\t\t}\n\t}\n\twhile(!INT0_GPIO && double_flag);//等待双击按键被松开\n}\n```\n\n#### main函数调用\n``` C\nif(key_flag){\n\tswitch(key_flag){\n\t\tcase 1:P2 = (0x01<<0);break;//短按\n\t\tcase 2:P2 = (0x01<<1);break;//长按\n\t\tcase 3:P2 = (0x01<<2);break;//双击\n\t}\n\tkey_flag = 0;\n}\n```\n\n#### 使用到的延时函数 (两个不可少)\n``` C\nvoid delay(u16 u)\t\t//@11.0592MHz\n{\n\tunsigned char i, j;\n\twhile (u--)\n\t{\n\t\t_nop_();\n\t\ti = 2;\n\t\tj = 199;\n\t\tdo\n\t\t{\n\t\t\twhile (--j)\n\t\t\t\t;\n\t\t} while (--i);\n\t}\n}\nbit button_delay(u16 u)\t\t//@11.0592MHz\n{\n\tunsigned char i, j;\n\tif(u == 50)delay(100);//延时50ms以后再判断按钮是否被按下，否则在双击前抬起瞬间就会被跳过判断\n\twhile (u--)\n\t{\n\t\t_nop_();\n\t\ti = 2;\n\t\tj = 199;\n\t\tdo\n\t\t{\n\t\t\tif(INT0_GPIO)return 0;//按键被松开时返回0\n\t\t\twhile (--j)\n\t\t\t\t;\n\t\t} while (--i);\n\t}\n\treturn 1;\n}\n```\n\n工程源码(Keil and VS code(EIDE))以及Proteus(V8.9)仿真\n链接：https://pan.baidu.com/s/1P10nqMTQnNDS0q9ZyY6WIA \n提取码：qi5h \n\n\n\n","slug":"button-exti","link":"","permalink":"https://2103210500.github.io/2020/05/04/button-exti/","tags":[]},{"title":"STM32F429使用HAL库串口DMA不定长度数据接收","date":"2020-04-03T15:23:59.000Z","path":"2020/04/03/uart_dma_receive/","raw":"---\ntitle: STM32F429使用HAL库串口DMA不定长度数据接收\ndate: 2020-04-03 23:23:59\ntags:\n---\n\n\n#### MCU型号：STM32F429IGT6\n#### 基于HAL库实现\n> 在stm32中，串口接收和发送大量数据时会占用很多系统资源，使用DMA传输会极大减轻CPU负担，我们在配置DMA接收串口数据时需要调用HAL_UART_Receive_DMA()函数来开启DMA接收，由于使用DMA接收，必须给它一个缓存数组，以及接收的长度，他才能自己去干这件事情，这就导致它的接收长度是一个相对固定的数，假如我定义接收20个字符，当我们数据是10个字符时，发送给串口，DMA并不会产生中断，因为数据没有达到定义的长度，这就很不方便。利用串口的空闲中断-UART_IT_IDLE，可实现数据接收结束的判断。\n\n定义缓存数组和数据长度变量\n``` C\nuint8_t b_buf[256] = {0};\t//数据缓存数组\nuint8_t b_len = 255;\t\t//每次最大接收数据长度\n```\n\n``` C\nHAL_UART_Receive_DMA(&huart1,(uint8_t*)b_buf,b_len);\t//开启DMA接收\n__HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE);\t\t\t\t//开启空闲中断\nwhile(1);\n```\n\n在STM32f4xx_hal_uart.c中 第2024行，判断UART_FLAG_IDLE标志位\n``` C\nif(__HAL_UART_GET_FLAG(huart,UART_FLAG_IDLE) != RESET) {\t//判断RX空闲标志位\n   __HAL_UART_CLEAR_IDLEFLAG(huart);\t\t\t\t\t\t//清楚标志位\n   UART_IDLCallback(huart);\t\t\t\t\t\t\t\t\t//创建回调函数\n}\n//声明回调函数\n__weak void UART_IDLCallback(UART_HandleTypeDef *huart) {\n\tUNUSED(huart);\n}\n```\n在main.c中重写回调函数\n``` C\n\nextern DMA_HandleTypeDef hdma_usart1_rx;\nvoid UART_IDLCallback(UART_HandleTypeDef *huart) {\n    HAL_UART_DMAStop(huart);//停止DMA接收\n    uint8_t data_lenth = b_len - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);//计算数据长度\n    \n\t\n    printf(\"接收完成\\r\\n\");\n\tprintf(\"数据长度：%d\\r\\n\",data_lenth);\n    printf(\"数据内容：%s\\r\\n\",b_buf);\n\t\n\tmemset(b_buf,0,b_len);//清空数据\n\t\n    HAL_UART_Receive_DMA(huart,(uint8_t *)b_buf,b_len);//重新开启DMA\n}\n\n```\n\n实验结果图\n<img src = \"https://2103210500.github.io/2020/04/03/uart_dma_receive/b.PNG\">\n\n\n\t","slug":"uart_dma_receive","link":"","permalink":"https://2103210500.github.io/2020/04/03/uart_dma_receive/","tags":[]},{"title":"51modbus","date":"2020-03-13T11:02:16.000Z","path":"2020/03/13/51modbus/","raw":"---\ntitle: 51modbus\ndate: 2020-03-13 19:02:16\ntags:\n---\n\n### 基于51单片机的ModeBus通讯协议实现\n#### 定义全局变量\n``` C\nu8 bf[15];\t\t\t\t//接收数据缓存数组\nu8 sb[15] = {2,3,4};\t//发送数据数组\n/*\t2 代表远端站号\n\t3:通讯功能码（03：读寄存器）\n\t4：数长度\t（4 数据大小为4字节）*/\n\t\nu8 time,\t\t\t\t//超时判断时间记录变量\n\tflag,\t\t\t\t//数据接收标志位\n\tlen,\t\t\t\t//数据长度\n\tblen;\t\t\t\t//缓存数据长度\n```\n\n#### 初始化串口为9600波特率\n``` C\n\tSCON = 0x50;                //8位可变波特率\n    TL1 = (65536 - (FOSC/4/12/9600));   //设置波特率重装值\n    TH1 = (65536 - (FOSC/4/12/9600))>>8;\n    TR1 = 1;                    //定时器1开始启动\n    ES = 1;                     //使能串口中断\n\t\n//串口中断函数\nvoid Uart() interrupt 4\n{\n    if (RI)\n    {\n        RI = 0;                 //清除RI位\n\t\tbf[blen++] = SBUF;\t\t//将数据存入缓存数组，并且缓存长度+1\n\t\ttime = 11;\t\t\t\t//设置超时时间为10ms\n    }\n}\n\n```\n\n#### 配置定时器用开数据接收超时判断\n``` C\n    TMOD = 0x00;                    //设置定时器为模式0(16位自动重装载)\n    TL0 = -（11059200/1000）;       //定时为1MS\n    TH0 = -（11059200/1000） >> 8;\n    TR0 = 1;                        //定时器0开始计时\n    ET0 = 1;                        //使能定时器0中断\n    EA = 1;\n\t\n//中断函数\nvoid tm0_isr() interrupt 1\n{\n    if(time>1)time--;//判断如果超时时间没有倒计时完成则时间记录-1\n    else if(time== 1) {//倒计时完成\n\t\ttime = 0;\t\t//置0使下一次中断不再执行此过程\n\t\tlen = blen;\t\t//将缓存长度存入数据长度记录\n\t\tblen = 0;\t\t//缓存长度记录清0，使下次接收数据重新定位\n\t\tflag =1;\t\t//标志位置1\n    }\n}\n```\n#### 在while循环里监控flag数据标志位\n``` C\n//数据监控\nvoid uart_scanf(){\n\tif(flag){//检测到数据\n\t\tflag = 0;//清空标志位\n\t\tif(bf[0] == 2){//判断远端站号\n\t\t\tif(bf[1] == 3)rr(bf[3]);//判断是否为读功能码，则解码数据并跳转函数\n\t\t\telse if(bf[1] == 6)wr(bf[3],(bf[4]<<8)|bf[5]);//判断是否为写功能码\n\t\t}\n\t\t\n\t}\n}\n\n//串口发送函数\nvoid sendb(u8 *str,u8 len){\n\twhile(len--){\n\t\tSBUF = *str++;\n\t\twhile(!TI);\n\t\tTI = 0;\n\t}\t\n}\n\n//CRC16校验码生成函数\nu16 getcrc(u8 *str,u8 len){\n\tu16 c,i,s = 0xffff;\n\twhile(len--){\n\t\ts ^= *str++;\n\t\tfor(i = 0;i<8;i++){\n\t\t\tif(s&1)s = (s>>1)^0xA001;\n\t\t\telse s >>= 1;\n\t\t}\t\t\n\t}\n\tc = s>>8;\n\tc|= s<<8;\n\treturn c;\n}\n\n//读寄存器\nvoid rr(u8 a){\n\tu16 c;\n\tif(a == 1){//判断读地址\n\t\tsb[3] = 1234>>8;//写入数据到发送缓存数组\n\t\tsb[4] = 1234;\n\t\t\n\t\tsb[5] = 7890>>8;\n\t\tsb[6] = 7890;\n\t\tc = getcrc(sb,7);//计算校验码\n\t\tsb[7] = c>>8;\n\t\tsb[8] = c;\n\t\tsendb(sb,9);//发送数据\n\t}\n}\n\nvoid wr(u8 a,u16 v){\n\tif(a == 5){//判断写地址\n\t\tu16 tmp = v;//获取数据\n\t}\n\tsendb(bf,len);//返回数据\n}\n```\n** 此代码仅供参考 **","slug":"51modbus","link":"","permalink":"https://2103210500.github.io/2020/03/13/51modbus/","tags":[]},{"title":"基于CH340的51单片机自动下载电路设计","date":"2020-02-12T08:49:02.000Z","path":"2020/02/12/ch340-auto-download/","raw":"---\ntitle: 基于CH340的51单片机自动下载电路设计\ndate: 2020-02-12 16:49:02\ntags:\n---\n\n\n\nC4左端连接在CH340的RTS#引脚，根据CH340官方解释，此引脚为MODEM联络输出信号，请求发送，具体我也没有看个明白，不过根据实际测量，RTS#引脚上电默认为高电平，在下载程序或者打开串口时，此引脚电平会发生跳变，从高电平变为低电平，直到程序下载结束或关闭串口恢复为高电平，利用此引脚，实现51单片机的一键自动下载电路，但有一缺陷，在打开串口时同样会重启单片机，对一些串口通讯模块可能会照成影响，曾经使用自动下载器做串口通信连接语音模块时，导致模块无法通信，最终发现其原因就是因为自动下载电路的影响。\n\n### 电路分析\n上电时由于RTS#引脚为高电平，Q4基极也为高电平，C4两端无电压，Q4为不导通状态，故集电极C电压约为5V，此时MOS管导通，下载器输出5V。当下载程序时，RTS#引脚由高转低，经过C4使Q4导通，并使集电极电位降低，此时mos管关断，切断5V电源。但是由于上拉电阻R6的存在，C4有一个缓慢充电的过程，直到C4两端电压达到5V，当电压逐渐升高，Q4由导通变为关断，此时mos管导通，恢复5V电源供电。断电后恢复供电有一个时间间隔，调节C4和R6来改变间隔时间，改变单片机重启速度。\nRC充电时间计算公式：T = - RC * ln( (VCC - Vt)/Vcc)\n由于电路连接了三极管会吸收电流，具体充电时间需实际测量和测试来选择合适的电容电阻大小\n<img src = \"https://2103210500.github.io/2020/02/12/ch340-auto-download/a1.jpg\">\n","slug":"ch340-auto-download","link":"","permalink":"https://2103210500.github.io/2020/02/12/ch340-auto-download/","tags":[]},{"title":"力控登录界面账号密码判断逻辑","date":"2020-02-06T05:39:16.000Z","path":"2020/02/06/lg_user/","raw":"---\ntitle: 力控登录界面账号密码判断逻辑\ndate: 2020-02-06 13:39:16\ntags:\n---\n\n\n#### 实现功能：\n> 使用普通用户账号登录进入主机面，当普通用户的账号密码输入错误3次以上，锁定普通用户账号需使用管理员账号登录，当管理员账号密码错误3次以后，退出登录\n\n```VB\nIF #TextControl.Text == \"abc\" THEN \t\t\t\t//判断登录账号\n\tIF psw1>=3 THEN \t\t\t\t\t\t\t//判断普通用户登录次数\n\t\tMsgBox(\"账号已锁定,请使用管理员密码登录\");\t//登录次数大于三次锁定\n\tELSE\n\t\tIF #TextControl1.Text == \"abc\" THEN\t\t//判断普通用户密码是否正确\n\t\t\tDisplay(\"主界面\");\n\t\tELSE\n\t\t\tMsgBox(\"用户密码错误\");\n\t\t\tpsw1 = psw1 + 1;\t\t\t\t\t//密码错误，并记录错误次数\n \t\tENDIF\n \tENDIF\nELSE\n\tIF #TextControl.Text == \"admin\" THEN \t\t//判断是否为管理员账号\n\t\tIF #TextControl1.Text == \"123456\" THEN\t//判断管理员密码正确性\n\t\t\tDisplay(\"主界面\");\n\t\tELSE\n\t\t\tMsgBox(\"管理员密码错误\");\n\t\t\tpsw2 = psw2 + 1;\t\t\t\t\t//记录错误次数\n\t\t\tIF psw2 >3 THEN \t\t\t\t\t//密码错误大于三次退出\n\t\t\t\tExit(0);\t\t\t\t\t\t//退出程序\n\t\t\tENDIF\n \t\tENDIF\n\tELSE\n\t\tMsgBox(\"用户名错误！\");\t\t\t\t\t//既不是普通账号也不是管理员账号\n \tENDIF\nENDIF\n\n```\n\n##### 脚本仅供参考","slug":"lg_user","link":"","permalink":"https://2103210500.github.io/2020/02/06/lg_user/","tags":[]},{"title":"基于STM32实现WS2812驱动及GRB流水效果","date":"2020-01-28T05:18:31.000Z","path":"2020/01/28/ws2812/","raw":"---\ntitle: 基于STM32实现WS2812驱动及GRB流水效果\ndate: 2020-01-28 13:18:31\ntags:\n---\n\n> 单片机：STM32F103C8T6核心板\n\n#### 图片效果\n<img src = \"https://2103210500.github.io/2020/01/28/ws2812/a1.jpg\">\n<br>\n<img src = \"https://2103210500.github.io/2020/01/28/ws2812/a2.jpg\">\n\n> 视频效果：https://pan.baidu.com/s/13yQKHWRaR1NRaBlFGgIJfA提取码:vi2t\n\n\n\n### WS2812驱动代码\n```C\n#define TIMING_ONE  50\t//T1H\t1码\n#define TIMING_ZERO 25\t//T0L   0码\n\n\nvoid send_Data(uint32_t rgb)\n{\n\n    uint8_t r = (rgb&0xff0000)>>16;\n    uint8_t g = (rgb&0x00ff00)>>8;\n    uint8_t b = (rgb&0xff);\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[i] = (0x80&g)>0?TIMING_ONE:TIMING_ZERO;\n        g <<= 1;\n    }\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[8 + i] = (0x80&r)>0?TIMING_ONE:TIMING_ZERO;\n        r <<= 1;\n    }\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[16 + i] = (0x80&b)>0?TIMING_ONE:TIMING_ZERO;\n        b <<= 1;\n    }\n    DMA_SetCurrDataCounter(DMA1_Channel2, 24); \t// load number of bytes to be transferred\n    DMA_Cmd(DMA1_Channel2, ENABLE); \t\t\t// enable DMA channel 6\n    TIM_Cmd(TIM2, ENABLE); \t\t\t\t\t\t// enable Timer 3\n    while(!DMA_GetFlagStatus(DMA1_FLAG_TC2)) ; \t// wait until transfer complete\n    TIM_Cmd(TIM2, DISABLE); \t\t\t\t\t// disable Timer 3\n    DMA_Cmd(DMA1_Channel2, DISABLE); \t\t\t// disable DMA channel 6\n    DMA_ClearFlag(DMA1_FLAG_TC2); \t\t\t\t// clear DMA1 Channel 6 transfer complete flag\n}\n\nvoid WS2812B_TIM_init(void)\n{\n    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\n    TIM_OCInitTypeDef  TIM_OCInitStructure;\n    GPIO_InitTypeDef GPIO_InitStructure;\n    DMA_InitTypeDef DMA_InitStructure;\n\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n    /* GPIOA Configuration: TIM2 Channel 1 as alternate function push-pull */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n    /* Compute the prescaler value */\n    //PrescalerValue = (uint16_t) (SystemCoreClock / 24000000) - 1;\n    /* Time base configuration */\n    TIM_TimeBaseStructure.TIM_Period = 89; // 800kHz\n    TIM_TimeBaseStructure.TIM_Prescaler = 0;\n    TIM_TimeBaseStructure.TIM_ClockDivision = 0;\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);\n\n    /* PWM1 Mode configuration: Channel1 */\n    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n    TIM_OCInitStructure.TIM_Pulse = 0;\n    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n    TIM_OC1Init(TIM2, &TIM_OCInitStructure);\n\n    /* configure DMA */\n    /* DMA clock enable */\n    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);\n\n    /* DMA1 Channel6 Config */\n    DMA_DeInit(DMA1_Channel2);\n\n    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&TIM2->CCR1;\t// physical address of Timer 3 CCR1\n    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)LED_BYTE_Buffer;\t\t// this is the buffer memory\n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\t\t\t\t\t\t// data shifted from memory to peripheral\n    DMA_InitStructure.DMA_BufferSize = 24;\n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\t\t\t\t\t// automatically increase buffer index\n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\t\t\t\t\t\t\t// stop DMA feed after buffer size is reached\n    DMA_InitStructure.DMA_Priority = DMA_Priority_High;\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n\n    DMA_Init(DMA1_Channel2, &DMA_InitStructure);\n\n    /* 使能通道1 TIMx_UP */\n    TIM_DMACmd(TIM2, TIM_DMA_Update, ENABLE);\n}\n```\n\n### RGB流水算法的代码\n```C\n\n/**\n\tcolor_length 颜色过渡长度\n\tluminance \tLED亮度\n\treturn 数据总共长度\n\t*/\nuint32_t set_Color_Loop(uint8_t color_length,uint16_t luminance)\n{\n    float max_luminance = 0xff/100;\n    max_luminance *= luminance;\n    if(max_luminance>0xff)max_luminance = 0xff;\n    uint16_t led_luminance = (uint16_t)max_luminance;\n    //RGB = (uint32_t*)malloc(color_length*sizeof(uint32_t));\n    color_length -= 1;\n    for(uint8_t i=0; i<=color_length; i++) {\n        RGB[i] = (((led_luminance/color_length)*i)<<8)|((led_luminance/color_length)*(color_length-i));\t\t\t\t\t\t//蓝到绿\n        RGB[color_length + 1 +i] = (((led_luminance/color_length)*i)<<16)|((led_luminance/color_length)*(color_length-i))<<8; //绿到红\n        RGB[((color_length+1)*2) +i] = ((led_luminance/color_length)*i)|((led_luminance/color_length)*(color_length-i))<<16;  //红到蓝\n    }\n    return color_length*3;\n}\n\n/**\n * colorwidth 每次获取多少位\n */\n\nvoid out_RGB(uint16_t data_Max_Length,uint16_t colorwidth)\n{\n    static uint32_t rgb_position = 0;//自动位移\n//    uint32_t rgb_position = 0;\n    for(uint32_t i = 0; i < colorwidth; i++) {\n        uint16_t c = (rgb_position + i) % data_Max_Length;//末尾颜色数据结束时将首位的收据填充到数组\n        send_Data(RGB[c]);\n    }\n    rgb_position ++;\n    rgb_position %= data_Max_Length;\n}\n\n```\n\n------------\n### 在main函数里调用它即可\n<img src = \"https://2103210500.github.io/2020/01/28/ws2812/a3.jpg\">\n\n> C源文件 https://pan.baidu.com/s/1CKRylYId002p96DeFwCcGQ 提取码：o13k ","slug":"ws2812","link":"","permalink":"https://2103210500.github.io/2020/01/28/ws2812/","tags":[]},{"title":"基于51单片机的ModBus通讯协议CRC16校验","date":"2020-01-27T05:46:06.000Z","path":"2020/01/27/modbus_crc16/","raw":"---\ntitle: 基于51单片机的ModBus通讯协议CRC16校验\ndate: 2020-01-27 13:46:06\n---\n\n\n##### 单片机型号：STC15F2K60S2\n>代码兼容89等其它系列单片机\n\n```C\n/**\n  *@str 传输的数据地址\n  *@len 数据长度\n  *若数组有3个数据，len长度应填写为4\n*/\n\nunsigned int getCRC16(unsigned char * str,unsigned char len)\n{\n    unsigned int c,i,s = 0xffff;\n    while(len--)\n    {\n        s ^= *str++;\n        for(i = 0; i < 8; i ++) {\n            if( s&1 ) s = (s>>1)^0xA001;\n            else s >>= 1;\n        }\n    }\n    c = s>>8;\n    c |= s<<8;\n    return c;\n}\n```","slug":"modbus_crc16","link":"","permalink":"https://2103210500.github.io/2020/01/27/modbus_crc16/","tags":[]},{"title":"Hello World","date":"2020-01-21T11:28:22.623Z","path":"2020/01/21/hello-world/","raw":"---\ntitle: Hello World\n---\n\n## Hello!\n>这是他写下的第一篇文章，由于他很懒，将不会有很多文章，你可联系2103210500@qq.com来催促它\n#2020！祝大家新年快乐！\n\n------------\n\n#### C语言大法\n```C\nint main()\n{\n\tprintf(\"新年快乐，%d！\"，2020);\n\treturn 0;\n}\n\n```\n\n>#### 奈斯~","slug":"hello-world","link":"","permalink":"https://2103210500.github.io/2020/01/21/hello-world/","tags":[]}]