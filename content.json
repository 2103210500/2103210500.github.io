[{"title":"基于STM32103C8T6+DMA的WS2812驱动及GRB流水效果","date":"2020-01-28T05:18:31.000Z","path":"2020/01/28/ws2812/","raw":"---\ntitle: 基于STM32103C8T6+DMA的WS2812驱动及GRB流水效果\ndate: 2020-01-28 13:18:31\ntags:\n---\n\n> #### 单片机：STM32F103C8T6核心板\n\n------------\n{% asset_img a1.jpg %}\n{% asset_img a2.jpg %}\n\n> 视频效果：https://pan.baidu.com/s/13yQKHWRaR1NRaBlFGgIJfA提取码:vi2t\n\n------------\n\n\n### WS2812驱动代码\n```C\n#define TIMING_ONE  50\t//T1H\t1码\n#define TIMING_ZERO 25\t//T0L   0码\n\n\nvoid send_Data(uint32_t rgb)\n{\n\n    uint8_t r = (rgb&0xff0000)>>16;\n    uint8_t g = (rgb&0x00ff00)>>8;\n    uint8_t b = (rgb&0xff);\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[i] = (0x80&g)>0?TIMING_ONE:TIMING_ZERO;\n        g <<= 1;\n    }\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[8 + i] = (0x80&r)>0?TIMING_ONE:TIMING_ZERO;\n        r <<= 1;\n    }\n    for(uint16_t i=0; i<8; i++) {\n        LED_BYTE_Buffer[16 + i] = (0x80&b)>0?TIMING_ONE:TIMING_ZERO;\n        b <<= 1;\n    }\n    DMA_SetCurrDataCounter(DMA1_Channel2, 24); \t// load number of bytes to be transferred\n    DMA_Cmd(DMA1_Channel2, ENABLE); \t\t\t// enable DMA channel 6\n    TIM_Cmd(TIM2, ENABLE); \t\t\t\t\t\t// enable Timer 3\n    while(!DMA_GetFlagStatus(DMA1_FLAG_TC2)) ; \t// wait until transfer complete\n    TIM_Cmd(TIM2, DISABLE); \t\t\t\t\t// disable Timer 3\n    DMA_Cmd(DMA1_Channel2, DISABLE); \t\t\t// disable DMA channel 6\n    DMA_ClearFlag(DMA1_FLAG_TC2); \t\t\t\t// clear DMA1 Channel 6 transfer complete flag\n}\n\nvoid WS2812B_TIM_init(void)\n{\n    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\n    TIM_OCInitTypeDef  TIM_OCInitStructure;\n    GPIO_InitTypeDef GPIO_InitStructure;\n    DMA_InitTypeDef DMA_InitStructure;\n\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n    /* GPIOA Configuration: TIM2 Channel 1 as alternate function push-pull */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n    /* Compute the prescaler value */\n    //PrescalerValue = (uint16_t) (SystemCoreClock / 24000000) - 1;\n    /* Time base configuration */\n    TIM_TimeBaseStructure.TIM_Period = 89; // 800kHz\n    TIM_TimeBaseStructure.TIM_Prescaler = 0;\n    TIM_TimeBaseStructure.TIM_ClockDivision = 0;\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);\n\n    /* PWM1 Mode configuration: Channel1 */\n    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n    TIM_OCInitStructure.TIM_Pulse = 0;\n    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n    TIM_OC1Init(TIM2, &TIM_OCInitStructure);\n\n    /* configure DMA */\n    /* DMA clock enable */\n    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);\n\n    /* DMA1 Channel6 Config */\n    DMA_DeInit(DMA1_Channel2);\n\n    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&TIM2->CCR1;\t// physical address of Timer 3 CCR1\n    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)LED_BYTE_Buffer;\t\t// this is the buffer memory\n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\t\t\t\t\t\t// data shifted from memory to peripheral\n    DMA_InitStructure.DMA_BufferSize = 24;\n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\t\t\t\t\t// automatically increase buffer index\n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\t\t\t\t\t\t\t// stop DMA feed after buffer size is reached\n    DMA_InitStructure.DMA_Priority = DMA_Priority_High;\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n\n    DMA_Init(DMA1_Channel2, &DMA_InitStructure);\n\n    /* 使能通道1 TIMx_UP */\n    TIM_DMACmd(TIM2, TIM_DMA_Update, ENABLE);\n}\n```\n\n### RGB流水算法的代码\n```C\n\n/**\n\tcolor_length 颜色过渡长度\n\tluminance \tLED亮度\n\treturn 数据总共长度\n\t*/\nuint32_t set_Color_Loop(uint8_t color_length,uint16_t luminance)\n{\n    float max_luminance = 0xff/100;\n    max_luminance *= luminance;\n    if(max_luminance>0xff)max_luminance = 0xff;\n    uint16_t led_luminance = (uint16_t)max_luminance;\n    //RGB = (uint32_t*)malloc(color_length*sizeof(uint32_t));\n    color_length -= 1;\n    for(uint8_t i=0; i<=color_length; i++) {\n        RGB[i] = (((led_luminance/color_length)*i)<<8)|((led_luminance/color_length)*(color_length-i));\t\t\t\t\t\t//蓝到绿\n        RGB[color_length + 1 +i] = (((led_luminance/color_length)*i)<<16)|((led_luminance/color_length)*(color_length-i))<<8; //绿到红\n        RGB[((color_length+1)*2) +i] = ((led_luminance/color_length)*i)|((led_luminance/color_length)*(color_length-i))<<16;  //红到蓝\n    }\n    return color_length*3;\n}\n\n/**\n * colorwidth 每次获取多少位\n */\n\nvoid out_RGB(uint16_t data_Max_Length,uint16_t colorwidth)\n{\n    static uint32_t rgb_position = 0;//自动位移\n//    uint32_t rgb_position = 0;\n    for(uint32_t i = 0; i < colorwidth; i++) {\n        uint16_t c = (rgb_position + i) % data_Max_Length;//末尾颜色数据结束时将首位的收据填充到数组\n        send_Data(RGB[c]);\n    }\n    rgb_position ++;\n    rgb_position %= data_Max_Length;\n}\n\n```\n\n------------\n\n> #### C源文件 https://pan.baidu.com/s/1CKRylYId002p96DeFwCcGQ 提取码：o13k ","slug":"ws2812","link":"","permalink":"https://2103210500.github.io/2020/01/28/ws2812/","tags":[]},{"title":"基于51单片机的ModBus通讯协议CRC16校验","date":"2020-01-27T05:46:06.000Z","path":"2020/01/27/modbus_crc16/","raw":"---\ntitle: 基于51单片机的ModBus通讯协议CRC16校验\ndate: 2020-01-27 13:46:06\n---\n\n\n##### 单片机型号：STC15F2K60S2\n>代码兼容89等其它系列单片机\n\n```C\n/**\n  *@str 传输的数据地址\n  *@len 数据长度\n  *若数组有3个数据，len长度应填写为4\n*/\n\nunsigned int getCRC16(unsigned char * str,unsigned char len)\n{\n    unsigned int c,i,s = 0xffff;\n    while(len--)\n    {\n        s ^= *str++;\n        for(i = 0; i < 8; i ++) {\n            if( s&1 ) s = (s>>1)^0xA001;\n            else s >>= 1;\n        }\n    }\n    c = s>>8;\n    c |= s<<8;\n    return c;\n}\n```","slug":"modbus_crc16","link":"","permalink":"https://2103210500.github.io/2020/01/27/modbus_crc16/","tags":[]},{"title":"Hello World","date":"2020-01-21T11:28:22.623Z","path":"2020/01/21/hello-world/","raw":"---\ntitle: Hello World\n---\n\n## Hello!\n>这是他写下的第一篇文章，由于他很懒，将不会有很多文章，你可联系2103210500@qq.com来催促它\n#2020！祝大家新年快乐！\n\n------------\n\n#### C语言大法\n```C\nint main()\n{\n\tprintf(\"新年快乐，%d！\"，2020);\n\treturn 0;\n}\n\n```\n\n>#### 奈斯~","slug":"hello-world","link":"","permalink":"https://2103210500.github.io/2020/01/21/hello-world/","tags":[]}]